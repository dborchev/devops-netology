# Домашнее задание к занятию "6.6. Troubleshooting"

https://github.com/netology-code/virt-homeworks/blob/virt-11/06-db-06-troobleshooting/README.md

## Задача 1

>Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

>Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
>нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
  - используя `db.currentOp()` найдём проблемную операцию. Поскольку мы знаем, что операция принадлежит конкретному пользователю, то вызов `db.currentOp({ "$ownOps": true })` вернет операции этого пользователя
  - полученный opid передаём в качестве параметра в `db.killOp()` чтобы прервать операцию
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
  - для начала, нужно поэксперементировать (или найти метрики) и понять сколько времени такие операции занимают при нормальной работе, когда они успешны. Например, операцию можно повторить 1000 раз и взять 95-й персентиль за результат
  - опыт с другими системами подсказывает, что измеренное время нужно удвоить, чтобы получить таймаут который не будет завершать операции слишком рано
  - лучше всего быть избирательными и модифицировать код на стороне приложения, добавив параметр `.maxTimeMS(timeout)` к соответствующим операциям

## Задача 2

>Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

>Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
>Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
>увеличивается пропорционально количеству реплик сервиса. 

>При масштабировании сервиса до N реплик вы увидели, что:
>- сначала рост отношения записанных значений к истекшим
>- Redis блокирует операции записи

>Как вы думаете, в чем может быть проблема?

В данном случае, два утверждения должны быть верны:
+ похоже мы читаем ключи много реже, чем записываем. Поэтому, асинхронный ("ленивый") способ удаления не справляется. Этот способ удаляет истекший ключ при доступе к нему.
+ множество ключей с совпадающим временем истечения

Для таких случаев в Редис есть механизм активного удаления, который по-сути читает случайные ключи 10 раз в секунду, по 20 ключей (дефолт, можно изменить с параметром `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP`) за раз, вызывая удаление истекших. 10*20 = 200 - максимальное число ключей сканируемых в секунду.

Проблема "активного" алгоритма в том, что он пытается быть проактивным (ради экономии памяти) и считает число удаленных таким образмо ключей. Если это число больше 25%, сканирование повторяется. Это происходит пока доля удаленных за итерацию ключей не упадет ниже четверти.

Тут может быть важно, что удаление истекшего ключа происходит явно, по кластеру проходит операция DEL.

При достаточном числе ключей (как в нашем сценарии масштабирования) истекающих одновременно, этот механизм по сути вытесяняет и блокирует другие операции.

## Задача 3

>Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?
+ такая ошибка возникает по множеству причин (см. https://dev.mysql.com/doc/refman/8.0/en/gone-away.html ), из которых наиболее релевантным кажется вариант с превышением объема записей в ответе
+ записи не влезают в `max_allowed_packet`, приводя к сбросу соединения
+ возможно, как в примере, некоторые ГИС-данные хранятся в колонке формате BLOB

Какие пути решения данной проблемы вы можете предложить?
+ справка подсказывает увеличить `max_allowed_packet`, этот параметр может достигать 1ГБ (64МБ по-умолчанию)
+ можно перестать хранить такие большие неструктурированне объекты в базе вообще, и записывать в таблицу только ссылку на соответствующий файл и некоторые метаданные (например, размер и контрольную сумму). Это также позволяет снизить нагрузку на базу, перенеся обслуживание таких файлов на другие сервера.

## Задача 4

>Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
>большим объемом данных лучше, чем MySQL.

>После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
>
>`postmaster invoked oom-killer`

Как вы думаете, что происходит?
+ OOM о сообщении означает out of memory, killer соответственно прерывает процесс имеющий проблемы с памятью
+ например, либо мы сами (postgres) достигли потолка памяти, либо другой процесс вытесняет нас (в силу переподписки памяти) 
+ еще похоже, достаточно большой запрос (например, прямое произведение таблиц) может породить временную таблицу в памяти так, что она "не помещается"

Как бы вы решили данную проблему?
+ поставить больше памяти! Часто, память дешевле трудозатрат
  + как временный обходной вариант, можно расширить Swap (с потерей производительности), но наверное лучше не в проде
+ настроить параметры памяти собственно postgres, такие как work_mem, shared_buffers, huge_pages, temp_buffers
+ ясли проблема действительно в вытеснении, перенести postgres на выделенную машину, где проблема вытесянения другими процессами не возникнет
  + документация подсказывает также попробовать изменить параметры ядра ОС (linux) в части памяти, например убрать переподписку

