# Домашнее задание к занятию "6.1. Типы и структура СУБД"

https://github.com/netology-code/virt-homeworks/blob/virt-11/06-db-01-basics/README.md

## Задача 1

>Архитектор ПО решил проконсультироваться у вас, какой тип БД 
>лучше выбрать для хранения определенных данных.
>
>Он вам предоставил следующие типы сущностей, которые нужно будет хранить в БД.
>Выберите подходящие типы СУБД для каждой сущности и объясните свой выбор.

- Электронные чеки в json виде
  - подходит документо-ориентированная БД, поскольку структура данных внутри JSON-объекта нам неизвестна, наверняка будет меняться со временем (быстрый поиск показывает, "обязательные реквизиты кассового чека" меняют каждый год) 
  - также для предметной области хорошо подходит то свойство, что частота доступа к чекам обратно пропорциональна их возрасту, и можно устроить пайплайн "архивации" из документ-ориентированных БД (поскольку схемы как таковой нет, это просто копирование и удаление, без заботы о корректности конверсии типов данных), так что чек 10-летней давности все еще доступен, но например с задержкой извлечения в 24+ часов
- Склады и автомобильные дороги для логистической компании
  - логистическую сеть можно описать в графовой БД, поскольку характерные запросы предметной области отражаются в структуре данных (что-то вроде "путь от А до Б где Вместимость>N", или любые другие свойства)
- Генеалогические деревья
  - как и с дорогами, сложность отношений предствавима на графе наиболее близким к предметной области образом, а значит и графовая БД подходит наилучшим образом
  - напрашивается ответ "иерархические", но "дерево" в предметной области это скорее дань традиции (см. например генеалогию породистых животных, где "дедушки" одновременно -- родители на несколько поколений), чем реальность
- Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации
  - системы ключ-значение подходят лучше всего, особенно когда маршрутизация клиента устойчива в пределах времени жизни сессии 
- Отношения клиент-покупка для интернет-магазина
  - традиционным решением  для простой связи являются реляционные базы, поскольку собственно это они и моделируют
  - но с ростом сложности бизнес-процесса начинаются такие же проблемы как и с логистический сетью (сложность запросов пораждает проблемы с производительностью), и граф (например, с такиеми сущностями как: клиент, покупк(и), оплат(ы), средства оплаты, отправления, товары, адреса, склады, перевозчики, поставщики)

## Задача 2

>Вы создали распределенное высоконагруженное приложение и хотите классифицировать его согласно 
>CAP-теореме. Какой классификации по CAP-теореме соответствует ваша система, если 
>(каждый пункт - это отдельная реализация вашей системы и для каждого пункта надо привести классификацию):
>
>А согласно PACELC-теореме, как бы вы классифицировали данные реализации?

- Данные записываются на все узлы с задержкой до часа (асинхронная запись)
  - AP и PA/EC, при этом:
  - поскольку "доступные" по САР-теореме системы могут быть сколь-угодно медленнымм, тут описана А-система, но для строгого определния доступной (по САР-теореме) системы недостаточно данных в вопросе
  - толерантность к разделению в САР-теореме как раз подразумевает асинхронность (т.е. сеть между узлами с потерями и задержками) - можно предположить Р
  - для понятия консистентности в САР-теореме важен порядок следования операций записи-чтения, а о чтении тут ничего не сказано, поэтому мы не можем сказать, действительно ли мы жервуем консистентностью (может быть, пока идет часовая запись, мы перестаем отвечать на запросы чтения вообще, теряя доступность -- но следующий успешный запрос строго консистентен)
- При сетевых сбоях, система может разделиться на 2 раздельных кластера
  - CA и PA/E?, при этом:
  - поскольку из этого определения неизвестно, как ведет себя система в отсутствии разделения, то вторую половину PACELC описать нельзя -- может быть что угодно
  - СА тут -- это условность, поскольку мы опять же не имеем информации об операциях над данными, что гораздо важнее для теоремы
- Система может не прислать корректный ответ или сбросить соединение
  - никак нельзя классифицировать по этим теоремам
  - тут такой интересный случай, поскольку определения в теореме очень строги, то попытка подогнать под них вот такой однострочник непродуктивна
  - такая система, очевидно, жертвует доступностью, но мы ничего не знаем о других свойствах

## Задача 3

Могут ли в одной системе сочетаться принципы BASE и ACID? Почему?
- в одной базе данных -- нет, поскольку противоположны задачи этих моделей
  - собственно, Брюер придумал BASE как противоположность ACID, и описывет их как условные точки на спектре (см. например цитату в https://www.julianbrowne.com/article/brewers-cap-theorem )
- "в одной системе" -- может, поскольку разные части системы могут иметь разные требования, и даже в электронной коммерции, выставление товара во фронтэнд каталога может быть расслабленным, ближе к BASE, но финасновый поток ("покупка") должен пройти жестко через ACID-транзакцию

## Задача 4

>Вам дали задачу написать системное решение, основой которого бы послужили:
>
>- фиксация некоторых значений с временем жизни
>- реакция на истечение таймаута
>
>Вы слышали о key-value хранилище, которое имеет механизм [Pub/Sub](https://habr.com/ru/post/278237/). 
>Что это за система? Какие минусы выбора данной системы?

Такой системой будет Redis. Redis -- это key-value база, использующая механизм
Pub/Sub, и поддерживающая время жизни (TTL) с возможностью реакции на его истечение. 

Поскольку эта система приоретизирует производительность, она хранит все данные в памяти.
Это ведет за собой повышения требований к памяти узла. Сброс данных на диск в Redis -- только для восстановления при отказе.

Централизованная архитектура такова, что можно потерять данные. Даже в кластерной организации, судя по всему.
Даже переключение ведомого узла в ведущий режим занимает время человеческого масштаба (десятки секунд), т.е. новые записи пришедшие за это время будут потеряны.

Поскольку все записи идут через ведущий сервер, к нему требования также выше (если в системе будет большая доля операций записи)

Отсутствие встроенного контроля доступа, если оно требуется в нашей системе -- нужно надстраивать перед Редисом своего рода прокси
